{
    "docs": [
        {
            "location": "/", 
            "text": "Fast Connect 3 Credential Insertion API for Citrix Receiver for Windows\n\n\nThe Fast Connect 3 Credential Insertion API provides an interface that\nsupplies user credentials to the single sign-on (SSO) feature of Citrix\nReceiver for Windows 4.2 and later. Using this API, Citrix partners can provide authentication and SSO products that use StoreFront or the\nWeb Interface to log users on to virtual applications or desktops and\nthen disconnect users from those sessions.\n\n\nThe system requirements and prerequisites for the API are the same as\nthose for Receiver. Note that XenDesktop 7 does not support the Web\nInterface.\n\n\nThe Fast Connect 2 API is still available, but can be used only with\nReceiver for Windows 3.4.", 
            "title": "Introduction"
        }, 
        {
            "location": "/#fast-connect-3-credential-insertion-api-for-citrix-receiver-for-windows", 
            "text": "The Fast Connect 3 Credential Insertion API provides an interface that\nsupplies user credentials to the single sign-on (SSO) feature of Citrix\nReceiver for Windows 4.2 and later. Using this API, Citrix partners can provide authentication and SSO products that use StoreFront or the\nWeb Interface to log users on to virtual applications or desktops and\nthen disconnect users from those sessions.  The system requirements and prerequisites for the API are the same as\nthose for Receiver. Note that XenDesktop 7 does not support the Web\nInterface.  The Fast Connect 2 API is still available, but can be used only with\nReceiver for Windows 3.4.", 
            "title": "Fast Connect 3 Credential Insertion API for Citrix Receiver for Windows"
        }, 
        {
            "location": "/whats-new/", 
            "text": "What\u2019s new\n\n\n\n\nFallback to explicit credentials when using Web Interface or StoreFront Legacy XenApp Services Store\n\n\n-terminate\n allows the disconnection of applications that were not launched by Self-Service (for example, using \n.ica\n files or through the web site)\n\n\nPnaSSOnEnabled\n registry keys no longer need to be set for Web Interface-based environments \n\n\nSimpler installation and configuration using Group Policy with imported ADM/ADMX template \n\n\nSimpler integration with Receiver\u2019s Self-Service Plug-in", 
            "title": "What's new"
        }, 
        {
            "location": "/whats-new/#whats-new", 
            "text": "Fallback to explicit credentials when using Web Interface or StoreFront Legacy XenApp Services Store  -terminate  allows the disconnection of applications that were not launched by Self-Service (for example, using  .ica  files or through the web site)  PnaSSOnEnabled  registry keys no longer need to be set for Web Interface-based environments   Simpler installation and configuration using Group Policy with imported ADM/ADMX template   Simpler integration with Receiver\u2019s Self-Service Plug-in", 
            "title": "What\u2019s new"
        }, 
        {
            "location": "/setting-up-your-environment/", 
            "text": "Setting up your environment\n\n\nTo use the Fast Connect API you must first configure your site\nappropriately, including setting up SSO:\n\n\n\n\nIf you are using StoreFront, enable the HTTP Basic authentication method as follows:\n\n\n\nInstall Citrix Receiver for Windows 4.2 or later using the \n/includesson\n flag: \nCitrixReceiver.exe/includesson\n\n\n\n\nBy default, user credentials are captured at Windows session logon. This may not always be desirable, especially in off-domain pass-through scenarios; to disable logon credential capture, use the \nLOGON\\_CREDENTIAL\\_CAPTURE\\_ENABLE\n setting:\n\n\nCitrixReceiver.exe/includesson\nLOGON\\_CREDENTIAL\\_CAPTURE\\_ENABLE=No\n\n\n\n\n\n\n\n\n\nImport the \nreceiver.adml\n and \nreceiver.admx\n files and then open \ngpedit.msc\n. This will make the Group Policy templates appear within the gpedit.msc\nGUI. \n  \n\n\n\n\n\n\n\n\nNote\n\n\nFor information on importing Citrix Receiver for Windows Group Policy administrative template for Citrix Receiver for Windows Version 4.5, see \nCitrix Product Documentation.\n\n\nFor information on importing Citrix Receiver for Windows Group Policy administrative template for Citrix Receiver for Windows Version 4.6, see \nCitrix Product Documentation.\n\n\n\n\n\n\n\n\n. Navigate to the administrative templates folder and then select \nCitrix Components\n \n \nCitrix Receiver\n \n \nUser authentication\n.\n\n\n. Select the GPO policy Kerberos authentication, double-click it, and then disable it.\n\n\n\n\nNote\nThe order in which you configure policies is important. You must disable Kerberos authentication before configuring the Local user name and password policy as described in step 6. \n\n\n\n\n\n\n. To allow SSO functionality, locate the GPO policy Local user name and password, double-click it, and then enable the following options:\n\n\n\n\nEnable pass-through authentication\n\n\nAllow pass-through authentication for all ICA connections\n\n\n\n\n. Navigate to the administrative templates folder and then select \nCitrix Components\n \n \nCitrix Receiver\n \n \nFast Connect API Support\n\n\n. To allow Fast Connect functionality, locate the GPO policy Manage FastConnectAPI support, double-click it, and then enable the following options:\n\n\n\n\nEnable the GPO\n\n\nEnable Fast Connect API Functionality Disable Leave Apps Running On\n\n\nLogoff\n\n\nEnable Integrate Self Service Plugin with FastConnect\n\n\n\n\n. Optionally, in the administrative templates folder, select \nCitrix Components\n \n \nCitrix Receiver\n \n \nSelfService\n \n \nManage App shortcut\n:\n\n\n\n\nStartmenu Directory = Citrix\n\n\nDesktop Directory = Citrix\n\n\nDisable Startmenu Shortcut = False (clear checkbox)\n\n\nEnable Desktop Shortcut = True (select checkbox )\n\n\nDisable Categorypath = True (select checkbox to use StoreFront categories in the Start menu)\n\n\nRemoveAppsOnLogoff = True (select checkbox)\n\n\nClear the set of applications shown in the Receiver Windows on log off = True (select checkbox)\n\n\nPrevent Receiver performing a refresh of the application list when opened = True (select checkbox)\n\n\nIgnore self service selection of apps and make all mandatory = False (clear checkbox), but True (select checkbox) if you are using Web Interface\n\n\n\n\n. Optionally, select \nSelfService\n \n \nControl when Receiver attempts to reconnect to existing sessions\n: \n\n\n\n\nEnable the policy\n\n\nChoose the appropriate combination of reconnect conditions\n\n\n\n\n Optionally, select \nSelfService\n \n \nEnable application Prelaunch\n. Enable this policy to disable prelaunch.\n\n\n. If you are using StoreFront, add the FQDN of the XenDesktop Controller to the intranet zone: \n\nYou can set this through Group Policy:\n\n\n\n\nSelect \nComputer Configuration\n \n \nAdministrative Templates\n \n \nWindows Components\n \n \nInternet Explorer\n \n \nInternet Control Panel\n \n \nSecurity Page\n\n\nSelect \nSite to Zone Assignment List\n, enable it, then add the FQDN of the XenDesktop Controller as a zone assignment with a value of \n1\n. For more details, see\n\nhttp://blogs.msdn.com/b/askie/archive/2012/06/05/how-to-configure-internet-explorer- security-zone-sites-using-group-polices.aspx\n\n\n\n\n. On the command line, rungpupdate/forceto apply these settings.\n\n\n Start Citrix Receiver from the Start menu.\n\n\n. When you are prompted for an account, specify the URL for your StoreFront Services Site, StoreFront XenApp Services Site, or Web Interface XenApp Services Site. \n\n\nA StoreFront URL looks like this: \nhttps://SMBSZ-XENAPPS1.xa.local/Citrix/Store/discovery\n\n\nA Web Interface URL looks like this: \nhttps://SMBSZXENAPPS1.xa.local/Citrix/PNAgent/config.xml\n\n\n\n\nNote\nIf you require an http (unsecure) URL, first perform step 13 above before re-attempting this step.\n\n\n\n\n\n\n. If you are using a HTTP site, set the following registry key to allow HTTP traffic for Citrix Receiver:\n\n\n\n\nOn 64-bit Windows:\n\n\n\n\nHKLM\\SOFTWARE\\Wow6432Node\\Citrix\\Authmanager\nName: ConnectionSecurityMode\nType: REG_SZ\nData: Any\n\n\n\n\n\n\n\nOn 32-bit Windows:\n\n\n\n\nHKLM\\SOFTWARE\\Citrix\\AuthManager\nName: ConnectionSecurityMode\nType: REG_SZ\nData: Any\n\n\n\n\n\n. Restart Citrix Receiver.\n\n\n. If you are using StoreFront, create the following registry keys and\nvalues on the endpoint(s) to allow HTTP Basic authentication, which is needed for SSO:\n\n\n\n\nOn 64-bit Windows:\n\n\n\n\nHKEY_LOCAL_MACHINE\\SOFTWARE\\Wow6432Node\\Citrix\\AuthManager\\Protocols\n\\httpbasic \nName: Enabled\nType: REG_SZ \nData: True\n\n\n\n\n\nHKEY_LOCAL_MACHINE\\SOFTWARE\\Wow6432Node\\Citrix\\AuthManager \nName: ProtocolOrder\nType: REG_MULTI_SZ\nValue: httpbasic\n\n\n\n\n\n\n\nOn 32-bit Windows:\n\n\n\n\nHKEY_LOCAL_MACHINE\\SOFTWARE\\Citrix\\AuthManager\\Protocols\\httpbasic \nName: Enabled\nType: REG_SZ \nData: True\n\n\n\n\n\nHKEY_LOCAL_MACHINE\\SOFTWARE\\Citrix\\AuthManager \nName: ProtocolOrder\nType: REG_MULTI_SZ\nData: httpbasic\n\n\n\n\n\n. To get the store accepted, log on as any user and restart the endpoint.\n\n\n. When the endpoint restarts, verify that the SSO functionality is enabled by running ssonsvr.exe, as described at \nhttp://support.citrix.com/article/CTX133855\n\n\n\n\n. You can now inject a user name and password into the SSO functionality by interacting with the Fast Connect API, using the LogonSsoUser() function described later in this document.\n\n\n. If you would like the Self-Service Plug-in UI to automatically log on and log off in response to the Fast Connect LogonSSOUser and LogoffSSOUser library calls and thereby update the user\u2019s icons, enable the policy \u201cIntegrate Self Service Plugin with FastConnect\u201d described in step 8.\n\n\nAlternatively, you can manually update the UI and desktop icons following these calls by using the following sequence:\n\n\nSelfService.exe \u2013ipoll          // Refreshes the SSP GUI\n\n\n\n\n\n. Start Receiver from the Start menu. The injected user will be logged on to Receiver.\n\n\nAll the user\u2019s applications then appear for the first time on the desktop, the Start menu, and within the SSP GUI.\n\n\n\n\n. To inject further user credentials into Receiver through Fast Connect, repeat Step 15. Receiver on the endpoint is now set up for SSO and Fast Connect API use.", 
            "title": "Setting up your environment"
        }, 
        {
            "location": "/setting-up-your-environment/#setting-up-your-environment", 
            "text": "To use the Fast Connect API you must first configure your site\nappropriately, including setting up SSO:   If you are using StoreFront, enable the HTTP Basic authentication method as follows:  Install Citrix Receiver for Windows 4.2 or later using the  /includesson  flag:  CitrixReceiver.exe/includesson   By default, user credentials are captured at Windows session logon. This may not always be desirable, especially in off-domain pass-through scenarios; to disable logon credential capture, use the  LOGON\\_CREDENTIAL\\_CAPTURE\\_ENABLE  setting:  CitrixReceiver.exe/includesson\nLOGON\\_CREDENTIAL\\_CAPTURE\\_ENABLE=No    Import the  receiver.adml  and  receiver.admx  files and then open  gpedit.msc . This will make the Group Policy templates appear within the gpedit.msc\nGUI.         Note  For information on importing Citrix Receiver for Windows Group Policy administrative template for Citrix Receiver for Windows Version 4.5, see  Citrix Product Documentation.  For information on importing Citrix Receiver for Windows Group Policy administrative template for Citrix Receiver for Windows Version 4.6, see  Citrix Product Documentation.     . Navigate to the administrative templates folder and then select  Citrix Components     Citrix Receiver     User authentication .  . Select the GPO policy Kerberos authentication, double-click it, and then disable it.   Note The order in which you configure policies is important. You must disable Kerberos authentication before configuring the Local user name and password policy as described in step 6.     . To allow SSO functionality, locate the GPO policy Local user name and password, double-click it, and then enable the following options:   Enable pass-through authentication  Allow pass-through authentication for all ICA connections   . Navigate to the administrative templates folder and then select  Citrix Components     Citrix Receiver     Fast Connect API Support  . To allow Fast Connect functionality, locate the GPO policy Manage FastConnectAPI support, double-click it, and then enable the following options:   Enable the GPO  Enable Fast Connect API Functionality Disable Leave Apps Running On  Logoff  Enable Integrate Self Service Plugin with FastConnect   . Optionally, in the administrative templates folder, select  Citrix Components     Citrix Receiver     SelfService     Manage App shortcut :   Startmenu Directory = Citrix  Desktop Directory = Citrix  Disable Startmenu Shortcut = False (clear checkbox)  Enable Desktop Shortcut = True (select checkbox )  Disable Categorypath = True (select checkbox to use StoreFront categories in the Start menu)  RemoveAppsOnLogoff = True (select checkbox)  Clear the set of applications shown in the Receiver Windows on log off = True (select checkbox)  Prevent Receiver performing a refresh of the application list when opened = True (select checkbox)  Ignore self service selection of apps and make all mandatory = False (clear checkbox), but True (select checkbox) if you are using Web Interface   . Optionally, select  SelfService     Control when Receiver attempts to reconnect to existing sessions :    Enable the policy  Choose the appropriate combination of reconnect conditions    Optionally, select  SelfService     Enable application Prelaunch . Enable this policy to disable prelaunch.  . If you are using StoreFront, add the FQDN of the XenDesktop Controller to the intranet zone:  \nYou can set this through Group Policy:   Select  Computer Configuration     Administrative Templates     Windows Components     Internet Explorer     Internet Control Panel     Security Page  Select  Site to Zone Assignment List , enable it, then add the FQDN of the XenDesktop Controller as a zone assignment with a value of  1 . For more details, see http://blogs.msdn.com/b/askie/archive/2012/06/05/how-to-configure-internet-explorer- security-zone-sites-using-group-polices.aspx   . On the command line, rungpupdate/forceto apply these settings.   Start Citrix Receiver from the Start menu.  . When you are prompted for an account, specify the URL for your StoreFront Services Site, StoreFront XenApp Services Site, or Web Interface XenApp Services Site.   A StoreFront URL looks like this:  https://SMBSZ-XENAPPS1.xa.local/Citrix/Store/discovery  A Web Interface URL looks like this:  https://SMBSZXENAPPS1.xa.local/Citrix/PNAgent/config.xml   Note If you require an http (unsecure) URL, first perform step 13 above before re-attempting this step.    . If you are using a HTTP site, set the following registry key to allow HTTP traffic for Citrix Receiver:   On 64-bit Windows:   HKLM\\SOFTWARE\\Wow6432Node\\Citrix\\Authmanager\nName: ConnectionSecurityMode\nType: REG_SZ\nData: Any   On 32-bit Windows:   HKLM\\SOFTWARE\\Citrix\\AuthManager\nName: ConnectionSecurityMode\nType: REG_SZ\nData: Any  . Restart Citrix Receiver.  . If you are using StoreFront, create the following registry keys and\nvalues on the endpoint(s) to allow HTTP Basic authentication, which is needed for SSO:   On 64-bit Windows:   HKEY_LOCAL_MACHINE\\SOFTWARE\\Wow6432Node\\Citrix\\AuthManager\\Protocols\n\\httpbasic \nName: Enabled\nType: REG_SZ \nData: True  HKEY_LOCAL_MACHINE\\SOFTWARE\\Wow6432Node\\Citrix\\AuthManager \nName: ProtocolOrder\nType: REG_MULTI_SZ\nValue: httpbasic   On 32-bit Windows:   HKEY_LOCAL_MACHINE\\SOFTWARE\\Citrix\\AuthManager\\Protocols\\httpbasic \nName: Enabled\nType: REG_SZ \nData: True  HKEY_LOCAL_MACHINE\\SOFTWARE\\Citrix\\AuthManager \nName: ProtocolOrder\nType: REG_MULTI_SZ\nData: httpbasic  . To get the store accepted, log on as any user and restart the endpoint.  . When the endpoint restarts, verify that the SSO functionality is enabled by running ssonsvr.exe, as described at  http://support.citrix.com/article/CTX133855   . You can now inject a user name and password into the SSO functionality by interacting with the Fast Connect API, using the LogonSsoUser() function described later in this document.  . If you would like the Self-Service Plug-in UI to automatically log on and log off in response to the Fast Connect LogonSSOUser and LogoffSSOUser library calls and thereby update the user\u2019s icons, enable the policy \u201cIntegrate Self Service Plugin with FastConnect\u201d described in step 8.  Alternatively, you can manually update the UI and desktop icons following these calls by using the following sequence:  SelfService.exe \u2013ipoll          // Refreshes the SSP GUI  . Start Receiver from the Start menu. The injected user will be logged on to Receiver.  All the user\u2019s applications then appear for the first time on the desktop, the Start menu, and within the SSP GUI.   . To inject further user credentials into Receiver through Fast Connect, repeat Step 15. Receiver on the endpoint is now set up for SSO and Fast Connect API use.", 
            "title": "Setting up your environment"
        }, 
        {
            "location": "/api-functions/", 
            "text": "API functions\n\n\nThe API provides four functions to enable the use of SSO:\n\n\n\n\nLogonSSOUser\n\n\nLogonSSOUserWithPin\n\n\nLogoffSSOUser\n\n\nIsReconnectioninProgress\n\n\n\n\nLogonSsoUser\n\n\nLOGONSSOUSER_ERROR_CODE\n \nAPIENTRY\n\n\nLogonSsoUser\n \n(\n\n              \nMSV1_0_INERACTIVE_LOGON\n           \npNewCredentials\n,\n\n              \nBOOL\n                              \nnotUsed\n,\n\n              \nBOOL\n                              \nnotUsed2\n,\n\n              \nDWORD\n                             \n*\npDwResult\n\n              \n)\n\n\n\n\n\n\nThis function is used to provide user credentials to SSO. If this function is invoked from a service, the service should be able to call these APIs in the locally logged-on user\u2019s session.\n\n\n\n\n\n\n\n\nParameter\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\npNewCredentials\n\n\nThis parameter is a pointer to the \nMSV1_0_INTERACTIVE_LOGON\n structure, which provides the users credentials to SSO.  See \nhttp://msdn.microsoft.com/en- us/library/aa378760(v=VS.85).aspx\n for further details on this structure.\n\n\n\n\n\n\nnotUsed\n, \nnotUsed2\n\n\nThese parameters are deprecated.\n\n\n\n\n\n\npDwResult\n\n\nPointer to a \nDWORD\n to contain the result code of this operation.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nReturn value\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nLOGONSSOUSER_OK\n\n\nOperation completed succesfully.\n\n\n\n\n\n\nLOGONSSOUSER_UNABLE_TO_GET_PIPE_NAME\n\n\nError communicating with SSO.\n\n\n\n\n\n\nLOGONSSOUSER_UNABLE_TO_CONNECT_TO_SSO\n\n\nError communicating with SSO.\n\n\n\n\n\n\nLOGONSSOUSER_UNABLE_TO_SEND_REQUEST\n\n\nError communicating with SSO.\n\n\n\n\n\n\nLOGONSSOUSER_INVALID_RESPONSE\n\n\nError in SSO response.\n\n\n\n\n\n\n\n\nLogonSsoUserWithPin\n\n\nBOOL\n \nAPIENTRY\n \nDoLogonSsoUserWithPin\n\n            \n(\n\n                    \nconst\n \nwchar_t\n*\n \npin\n\n            \n)\n\n\n\n\n\n\nThis function is used to provide smart card user credentials to SSO.\n\n\n\n\n\n\n\n\nParameter\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\npin\n\n\nThe smart card PIN\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nReturn value\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nBOOLEAN\n\n\nTRUE\n if operation completed successfully, \nFALSE\n otherwise.\n\n\n\n\n\n\n\n\nLogoffSSOUser\n\n\nDWORD APIENTRY\nLogoffSsoUser(\n                DWORD           notUsed\n              )\n\n\n\n\n\nThis function removes the credentials of the current SSO user and restores the previous user\u2019s credentials if available.\n\n\n\n\n\n\n\n\nParameter\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nnotUsed\n\n\nThis parameter is deprecated.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nReturn value\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nLOGONSSOUSER_OK\n\n\nOperation completed succesfully.\n\n\n\n\n\n\nLOGONSSOUSER_UNABLE_TO_GET_PIPE_NAME\n\n\nError communicating with SSO.\n\n\n\n\n\n\nLOGONSSOUSER_UNABLE_TO_CONNECT_TO_SSO\n\n\nError communicating with SSO.\n\n\n\n\n\n\nLOGONSSOUSER_UNABLE_TO_SEND_REQUEST\n\n\nError communicating with SSO.\n\n\n\n\n\n\nLOGONSSOUSER_INVALID_RESPONSE\n\n\nError in SSO response.\n\n\n\n\n\n\n\n\nIsReconnectInProgress\n\n\nDWORD APIENTRY\nIsReconnectInProgress\n             (\n             DWORD dwTimeout,\n             LPBOOL lpReconnectInProgress\n)\n\n\n\n\n\nThis function works with auto client reconnect to determine whether a reconnect is being attempted after the last logon using \nLogonSsoUser()\n. You must call it immediately after \nLogonSsoUser\n. If there is a session to reconnect, the auto client reconnect feature issues the reconnect request. The API communicates that a new reconnect request has been issued; therefore no new session launch request is needed.\n\n\nThe function detects only whether a reconnect request has been attempted. It cannot detect whether the reconnect succeeded or failed.\n\n\nFor this function to operate successfully for the Web Interface, you must enable the XenApp Services site setting Automatically reconnect to sessions when users log on.\n\n\n\n\n\n\n\n\nParameter\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\ndwTimeout\n\n\nThe maximum number of millisconds to wait to determine whether a reconnect is in progress.\n\n\n\n\n\n\nlpReconnectInProgress\n\n\nPoints to a flag that is set to TRUE if the reconnect request was launched after the last logon or to FALSE if there was no session to reconnect.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nReturn value\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nERROR_SUCCESS\n\n\nOperation completed successfully\n\n\n\n\n\n\nERROR_TIMEOUT\n\n\nThe timeout period expired or another relevant error code was issued.", 
            "title": "API functions"
        }, 
        {
            "location": "/api-functions/#api-functions", 
            "text": "The API provides four functions to enable the use of SSO:   LogonSSOUser  LogonSSOUserWithPin  LogoffSSOUser  IsReconnectioninProgress", 
            "title": "API functions"
        }, 
        {
            "location": "/api-functions/#logonssouser", 
            "text": "LOGONSSOUSER_ERROR_CODE   APIENTRY  LogonSsoUser   ( \n               MSV1_0_INERACTIVE_LOGON             pNewCredentials , \n               BOOL                                notUsed , \n               BOOL                                notUsed2 , \n               DWORD                               * pDwResult \n               )   This function is used to provide user credentials to SSO. If this function is invoked from a service, the service should be able to call these APIs in the locally logged-on user\u2019s session.     Parameter  Description      pNewCredentials  This parameter is a pointer to the  MSV1_0_INTERACTIVE_LOGON  structure, which provides the users credentials to SSO.  See  http://msdn.microsoft.com/en- us/library/aa378760(v=VS.85).aspx  for further details on this structure.    notUsed ,  notUsed2  These parameters are deprecated.    pDwResult  Pointer to a  DWORD  to contain the result code of this operation.        Return value  Description      LOGONSSOUSER_OK  Operation completed succesfully.    LOGONSSOUSER_UNABLE_TO_GET_PIPE_NAME  Error communicating with SSO.    LOGONSSOUSER_UNABLE_TO_CONNECT_TO_SSO  Error communicating with SSO.    LOGONSSOUSER_UNABLE_TO_SEND_REQUEST  Error communicating with SSO.    LOGONSSOUSER_INVALID_RESPONSE  Error in SSO response.", 
            "title": "LogonSsoUser"
        }, 
        {
            "location": "/api-functions/#logonssouserwithpin", 
            "text": "BOOL   APIENTRY   DoLogonSsoUserWithPin \n             ( \n                     const   wchar_t *   pin \n             )   This function is used to provide smart card user credentials to SSO.     Parameter  Description      pin  The smart card PIN        Return value  Description      BOOLEAN  TRUE  if operation completed successfully,  FALSE  otherwise.", 
            "title": "LogonSsoUserWithPin"
        }, 
        {
            "location": "/api-functions/#logoffssouser", 
            "text": "DWORD APIENTRY\nLogoffSsoUser(\n                DWORD           notUsed\n              )  This function removes the credentials of the current SSO user and restores the previous user\u2019s credentials if available.     Parameter  Description      notUsed  This parameter is deprecated.        Return value  Description      LOGONSSOUSER_OK  Operation completed succesfully.    LOGONSSOUSER_UNABLE_TO_GET_PIPE_NAME  Error communicating with SSO.    LOGONSSOUSER_UNABLE_TO_CONNECT_TO_SSO  Error communicating with SSO.    LOGONSSOUSER_UNABLE_TO_SEND_REQUEST  Error communicating with SSO.    LOGONSSOUSER_INVALID_RESPONSE  Error in SSO response.", 
            "title": "LogoffSSOUser"
        }, 
        {
            "location": "/api-functions/#isreconnectinprogress", 
            "text": "DWORD APIENTRY\nIsReconnectInProgress\n             (\n             DWORD dwTimeout,\n             LPBOOL lpReconnectInProgress\n)  This function works with auto client reconnect to determine whether a reconnect is being attempted after the last logon using  LogonSsoUser() . You must call it immediately after  LogonSsoUser . If there is a session to reconnect, the auto client reconnect feature issues the reconnect request. The API communicates that a new reconnect request has been issued; therefore no new session launch request is needed.  The function detects only whether a reconnect request has been attempted. It cannot detect whether the reconnect succeeded or failed.  For this function to operate successfully for the Web Interface, you must enable the XenApp Services site setting Automatically reconnect to sessions when users log on.     Parameter  Description      dwTimeout  The maximum number of millisconds to wait to determine whether a reconnect is in progress.    lpReconnectInProgress  Points to a flag that is set to TRUE if the reconnect request was launched after the last logon or to FALSE if there was no session to reconnect.        Return value  Description      ERROR_SUCCESS  Operation completed successfully    ERROR_TIMEOUT  The timeout period expired or another relevant error code was issued.", 
            "title": "IsReconnectInProgress"
        }, 
        {
            "location": "/launching-applications-and-session-management/", 
            "text": "Launching Applications and Session Management using the Self Service Plug-in (SSP)\n\n\nAll the following commands are called on SelfService.exe, which is\nlocated in \n%CitrixReceiverInstalllocation%\\SelfServicePlugin\n\n\nNote that command-line parameters are case-sensitive.\n\n\n-qlaunch \napplication friendly name\n\n\nThis command launches a named application by its friendly name. If the\napplication is already running it will automatically reconnect it.\n\n\nThis replaces pnagent.exe /CitrixShortcut: (2) /QLaunch \"ACME:Wordpad\"\n\n\n\u2013qlogon\n\n\nThis command gets the user\u2019s credentials from SSO and reconnects any\nactive user sessions.\n\n\nUse \n\u2013fastterminate\n or \n\u2013terminate\n first if a different user is logged on.\n\n\n-terminate\n\n\nThis command disconnects all current users\u2019 applications and exits.\n\n\nThis replaces \npnagent /terminate\n\n\n-fastterminate\n\n\nThis command logs off the current user and leaves their applications\nconnected. This is for use in shared endpoint scenarios.\n\n\n-terminateuser \nuser\n\n\nThis command disconnects a specific user\u2019s applications and exits.", 
            "title": "Launching Applications and Session Management using the Self Service Plug-in (SSP)"
        }, 
        {
            "location": "/launching-applications-and-session-management/#launching-applications-and-session-management-using-the-self-service-plug-in-ssp", 
            "text": "All the following commands are called on SelfService.exe, which is\nlocated in  %CitrixReceiverInstalllocation%\\SelfServicePlugin  Note that command-line parameters are case-sensitive.", 
            "title": "Launching Applications and Session Management using the Self Service Plug-in (SSP)"
        }, 
        {
            "location": "/launching-applications-and-session-management/#-qlaunch-application-friendly-name", 
            "text": "This command launches a named application by its friendly name. If the\napplication is already running it will automatically reconnect it.  This replaces pnagent.exe /CitrixShortcut: (2) /QLaunch \"ACME:Wordpad\"", 
            "title": "-qlaunch &lt;application friendly name&gt;"
        }, 
        {
            "location": "/launching-applications-and-session-management/#qlogon", 
            "text": "This command gets the user\u2019s credentials from SSO and reconnects any\nactive user sessions.  Use  \u2013fastterminate  or  \u2013terminate  first if a different user is logged on.", 
            "title": "\u2013qlogon"
        }, 
        {
            "location": "/launching-applications-and-session-management/#-terminate", 
            "text": "This command disconnects all current users\u2019 applications and exits.  This replaces  pnagent /terminate", 
            "title": "-terminate"
        }, 
        {
            "location": "/launching-applications-and-session-management/#-fastterminate", 
            "text": "This command logs off the current user and leaves their applications\nconnected. This is for use in shared endpoint scenarios.", 
            "title": "-fastterminate"
        }, 
        {
            "location": "/launching-applications-and-session-management/#-terminateuser-user", 
            "text": "This command disconnects a specific user\u2019s applications and exits.", 
            "title": "-terminateuser &lt;user&gt;"
        }, 
        {
            "location": "/examples/", 
            "text": "API examples\n\n\nA simple command-line driven test program is provided in the same .zip\nfile as this document as a sample to demonstrate the usage of these\nAPIs. Below are some code snippets from the sample.\n\n\nExample 1: Log on a user\n\n\nThe following code provides user credentials to SSO to log on a user.\n\n\nBOOL\n \nDoLogonSsoUser\n(\nconst\n \nwchar_t\n*\n \npUsername\n,\n \nconst\n \nwchar_t\n \n*\n \npPassword\n,\n \nconst\n \nwchar_t\n \n*\npDomain\n)\n\n\n{\n\n    \nDWORD\n \nrc\n;\n\n    \nDWORD\n \nresult\n;\n \n    \nMSV1_0_INTERACTIVE_LOGON\n \nmsv1Logon\n;\n\n\n    \nif\n(\n \n!\npUsername\n \n||\n \n!\n \npPassword\n \n||\n \n!\npDomain\n)\n \n        \nreturn\n \nFALSE\n;\n\n    \nmsv1Logon\n.\nUserName\n.\nLength\n \n=\n \n(\nUSHORT\n)(\nwcslen\n(\npUsername\n)\n \n*\n \n  \nsizeof\n(\nwchar_t\n));\n\n    \nmsv1Logon\n.\nUserName\n.\nMaximumLength\n \n=\n \nmsv1Logon\n.\nUserName\n.\nLength\n;\n \n    \nmsv1Logon\n.\nUserName\n.\nBuffer\n \n=\n \n(\nPWSTR\n)\npUsername\n;\n\n\n    \nmsv1Logon\n.\nPassword\n.\nLength\n \n=\n \n(\nUSHORT\n)(\nwcslen\n(\npPassword\n)\n \n*\n \n  \nsizeof\n(\nwchar_t\n));\n\n    \nmsv1Logon\n.\nPassword\n.\nMaximumLength\n \n=\n \nmsv1Logon\n.\nPassword\n.\nLength\n;\n \n    \nmsv1Logon\n.\nPassword\n.\nBuffer\n \n=\n \n(\nPWSTR\n)\npPassword\n;\n\n\n    \nmsv1Logon\n.\nLogonDomainName\n.\nLength\n \n=\n \n(\nUSHORT\n)(\nwcslen\n(\npDomain\n)\n \n*\n \n  \nsizeof\n(\nwchar_t\n));\n\n    \nmsv1Logon\n.\nLogonDomainName\n.\nMaximumLength\n \n=\n \nmsv1Logon\n.\nLogonDomainName\n.\nLength\n;\n\n    \nmsv1Logon\n.\nLogonDomainName\n.\nBuffer\n \n=\n \n(\nPWSTR\n)\npDomain\n;\n\n    \nmsv1Logon\n.\nMessageType\n \n=\n \nMsV1_0InteractiveLogon\n;\n\n\n    \nprintf\n(\ncalling LogonSsoUser...\n\\n\n);\n\n    \nrc\n \n=\n \nLogonSsoUser\n(\nmsv1Logon\n,\n \nFALSE\n,\n \nFALSE\n,\n \nresult\n);\n \n\n    \nSecureZeroMemory\n(\nmsv1Logon\n,\n \nsizeof\n(\nmsv1Logon\n));\n\n\n    \nif\n(\nrc\n \n!=\n \nLOGONSSOUSER_OK\n)\n \n{\n\n        \nprintf\n(\n\\n\nLogonSsoUser() failed: %d\n\\n\n,\n \nrc\n);\n \n        \nreturn\n \nFALSE\n;\n\n    \n}\n\n    \nprintf\n(\n\\n\n User logged on. Result of LogonSsoUser(): %d\n\\n\n,\n \nresult\n);\n \n    \nreturn\n \nTRUE\n;\n\n\n}\n\n\n\n\n\n\nExample 2: Log on a user with a smart card\n\n\nThe following code provides user credentials to SSO to log on a user with a smart card.\n\n\nBOOL\n \nDoLogonSsoUserWithPin\n(\nconst\n \nwchar_t\n*\n \npin\n)\n\n\n{\n\n    \nDWORD\n \nrc\n;\n\n    \nDWORD\n \nresult\n;\n\n    \nif\n \n(\nInitLibrary\n())\n\n    \n{\n\n        \nif\n(\n!\npin\n)\n\n        \n{\n\n            \nreturn\n \nFALSE\n;\n\n        \n}\n\n        \nif\n \n(\n!\npfnLogOnUserWithPin\n)\n\n        \n{\n\n            \nreturn\n \nFALSE\n;\n\n        \n}\n\n        \nprintf\n(\ncalling LogonSsoUserWithPin...\n\\n\n);\n\n        \nrc\n \n=\n \npfnLogOnUserWithPin\n(\npin\n,\n \ndisconnect\n,\n \nrestartPna\n,\n \nresult\n);\n\n        \nif\n(\nrc\n \n!=\n \nLOGONSSOUSER_OK\n)\n\n        \n{\n\n            \nprintf\n(\n\\n\nLogonSsoUserWithPin() failed: %d\n\\n\n,\n \nrc\n);\n \n            \nreturn\n \nFALSE\n;\n\n        \n}\n\n        \nprintf\n(\n\\n\n User logged on. Result of LogonSsoUserWithPin(): %d\n\\n\n,\n \nresult\n);\n\n        \nreturn\n \nTRUE\n;\n\n    \n}\n\n    \nprintf\n(\nInitLibrary() Failure\n\\n\n);\n \n    \nreturn\n \nFALSE\n;\n\n\n}\n\n\n\n\n\n\nExample 3: Log off a user\n\n\nThis function performs a logoff from an SSO perspective, removing the user\u2019s credentials from the system for the purposes of future SSO-based authorization. Existing authorized sessions can still be used. If the previous user was not logged off, that user\u2019s credentials are restored (see example 4).\n\n\nICO/CCM interfaces can be used to perform full logoff/disconnect.\n\n\nvoid\n \nDoLogoffSsoUser\n()\n\n\n{\n\n  \nif\n \n(\n \nLogoffSsoUser\n(\n0\n)\n \n==\n \nLOGONSSOUSER_OK\n \n)\n \n     \nprintf\n(\n\\n\n User logged off\n\\n\n);\n\n  \nelse\n\n     \nprintf\n(\n\\n\n Error logging off user\n\\n\n\u201d);\n\n\n}\n\n\n\n\n\n\nExample 4: Managing an exclusive endpoint\n\n\nIf the current user is not logged off and a new user is logged on, the previous user\u2019s credentials are saved by the system to be restored when the current user logs off. Only a single level of restore is supported. Logging off a second time without an intervening logon will result in clearing the SSO credentials and will require authentication before launching new sessions. This supports the following scenario using Controller, which is a custom application using \nCtxCredApi\n, \nICO\n:\n\n\n\n\nA kiosk is auto-logged on with a default/generic user (could be the normal Windows logon or Controller calls \nLogonSsoUser()\n)\n\n\nThe kiosk is then available with generic credentials for customer use.\n\n\nSales Rep A logs on with his own credentials:\n    a.  Controller calls \nLogonSsoUser()\n.\n    b. Controller disconnects generic user\u2019s sessions.\n    c. Controller roams existing sessions for Sales Rep A.\n\n\nThe kiosk can launch new sessions using Sales Rep A\u2019s credentials.\n\n\nSales Rep A logs off:\n    a. Controller calls \nLogoffSsoUser()\n, removing Sales Rep A\u2019s credentials and restoring the generic user.\n    b. Controller restores generic user\u2019s sessions.\n\n\nThe kiosk is back to its initial state and is available for use with generic credentials.\n\n\nSales Rep B logs on (repeat 3-5 for Sales Rep B).\n\n\nThe kiosk is back to its initial state.\n\n\n\n\nThis scenario can be repeated indefinitely.\n\n\nExample 5: Managing user restore and shared endpoints\n\n\nIf the current user is not logged off and a new user is logged on, the previous user\u2019s credentials are saved by the system to be restored when the current user logs off. Only a single level of restore is supported. Logging off a second time without an intervening logon will result in clearing the SSO credentials and will require authentication before launching new sessions. This supports the following scenario using Controller, which is a custom application using CtxCredApi, ICO:\n\n\n\n\nA nurse logs on normally and launches sessions. (Controller calls \nLogonSsoUser()\n or could be a Windows logon).\n\n\nA doctor \u201ctaps in\u201d:\n    a. Controller executes \nLogonSsoUser()\n with the doctor\u2019s credentials.\n    b. Controller does not log off the nurse or disconnect sessions.\n    c. Controller causes any existing doctor\u2019s sessions to be roamed to this endpoint .\n\n\nAt this point both the nurse\u2019s and the doctor\u2019s sessions are active. New sessions will be launched using the doctor\u2019s credentials.\n\n\nThe doctor \u201ctaps out\u201d:\n    a. Controller calls \nLogoffSsoUser()\n, removing the doctor\u2019s credentials and restoring the nurse\u2019s.\n    b. Controller disconnects the doctor\u2019s sessions.\n    c. The nurse\u2019s sessions are still active. \n\n\nThe nurse resumes as at Step 1.\n\n\n\n\nExample 6: Checking for reconnecting sessions\n\n\nSome applications may need to determine whether sessions are being reconnected before launching new instances. The ICO interface, ICACLient::EnumerateCCMSessions(), reports the IDs of the ICA sessions that already exist and that are being formed. This interface can be used by the caller to heuristically determine whether new ICA sessions are being formed, for example after Receiver is restarted and is automatically reconnecting disconnected sessions.\n\n\nAfter Receiver restarts, the caller may call this operation several times at regular intervals for a reasonable period of time (for example, two seconds). If, during that time, the operation reports new ICA sessions, the caller can conclude that those sessions are the reconnected sessions. If the period of time expires and the operation reports no new ICA sessions, the caller can conclude that no session reconnect attempts are being made. The IsReconnectInProgress() API can also be used to check for reconnecting sessions, as shown in the following example:\n\n\nfor\n \n(\nint\n \ni\n \n=\n \n0\n;\n \ni\n \n \n40000\n;\n \ni\n \n+=\n \n2000\n)\n\n    \n{\n\n        \nprintf\n(\nIsReconnectInProgress %d seconds left to wait\n\\n\n,\n \n(\n40000\n \n-\n \ni\n)\n \n/\n\n\n1000\n);\n\n        \nBOOL\n \nbReconnectInProgress\n \n=\n \nFALSE\n;\n\n        \nDWORD\n \nstatus\n \n=\n \npfnIsReconnectInProgress\n(\n2000\n,\n\n\nbReconnectInProgress\n);\n\n        \nif\n \n(\nstatus\n \n==\n \nERROR_SUCCESS\n)\n\n        \n{\n\n            \nif\n \n(\nbReconnectInProgress\n)\n\n             \n{\n\n                \nprintf\n(\nIsReconnectInProgress: Reconnect in Progress\n\\n\n);\n\n             \n}\n\n             \nelse\n\n             \n{\n\n                \nprintf\n(\nIsReconnectInProgress: No Reconnect\n\\n\n);\n\n             \n}\n\n             \nbreak\n;\n\n        \n}\n\n        \nelse\n \nif\n \n(\nstatus\n \n==\n \nERROR_TIMEOUT\n)\n\n        \n{\n\n            \nprintf\n(\nIsReconnectInProgress: TIMEOUT\n\\n\n);\n\n        \n}\n\n        \nelse\n\n        \n{\n\n            \nprintf\n(\nIsReconnectInProgress: Error: %d\n\\n\n,\n \nstatus\n);\n \n            \nbreak\n;\n\n        \n}\n\n    \n}", 
            "title": "API examples"
        }, 
        {
            "location": "/examples/#api-examples", 
            "text": "A simple command-line driven test program is provided in the same .zip\nfile as this document as a sample to demonstrate the usage of these\nAPIs. Below are some code snippets from the sample.", 
            "title": "API examples"
        }, 
        {
            "location": "/examples/#example-1-log-on-a-user", 
            "text": "The following code provides user credentials to SSO to log on a user.  BOOL   DoLogonSsoUser ( const   wchar_t *   pUsername ,   const   wchar_t   *   pPassword ,   const   wchar_t   * pDomain )  { \n     DWORD   rc ; \n     DWORD   result ;  \n     MSV1_0_INTERACTIVE_LOGON   msv1Logon ; \n\n     if (   ! pUsername   ||   !   pPassword   ||   ! pDomain )  \n         return   FALSE ; \n     msv1Logon . UserName . Length   =   ( USHORT )( wcslen ( pUsername )   *  \n   sizeof ( wchar_t )); \n     msv1Logon . UserName . MaximumLength   =   msv1Logon . UserName . Length ;  \n     msv1Logon . UserName . Buffer   =   ( PWSTR ) pUsername ; \n\n     msv1Logon . Password . Length   =   ( USHORT )( wcslen ( pPassword )   *  \n   sizeof ( wchar_t )); \n     msv1Logon . Password . MaximumLength   =   msv1Logon . Password . Length ;  \n     msv1Logon . Password . Buffer   =   ( PWSTR ) pPassword ; \n\n     msv1Logon . LogonDomainName . Length   =   ( USHORT )( wcslen ( pDomain )   *  \n   sizeof ( wchar_t )); \n     msv1Logon . LogonDomainName . MaximumLength   =   msv1Logon . LogonDomainName . Length ; \n     msv1Logon . LogonDomainName . Buffer   =   ( PWSTR ) pDomain ; \n     msv1Logon . MessageType   =   MsV1_0InteractiveLogon ; \n\n     printf ( calling LogonSsoUser... \\n ); \n     rc   =   LogonSsoUser ( msv1Logon ,   FALSE ,   FALSE ,   result );  \n\n     SecureZeroMemory ( msv1Logon ,   sizeof ( msv1Logon )); \n\n     if ( rc   !=   LOGONSSOUSER_OK )   { \n         printf ( \\n LogonSsoUser() failed: %d \\n ,   rc );  \n         return   FALSE ; \n     } \n     printf ( \\n  User logged on. Result of LogonSsoUser(): %d \\n ,   result );  \n     return   TRUE ;  }", 
            "title": "Example 1: Log on a user"
        }, 
        {
            "location": "/examples/#example-2-log-on-a-user-with-a-smart-card", 
            "text": "The following code provides user credentials to SSO to log on a user with a smart card.  BOOL   DoLogonSsoUserWithPin ( const   wchar_t *   pin )  { \n     DWORD   rc ; \n     DWORD   result ; \n     if   ( InitLibrary ()) \n     { \n         if ( ! pin ) \n         { \n             return   FALSE ; \n         } \n         if   ( ! pfnLogOnUserWithPin ) \n         { \n             return   FALSE ; \n         } \n         printf ( calling LogonSsoUserWithPin... \\n ); \n         rc   =   pfnLogOnUserWithPin ( pin ,   disconnect ,   restartPna ,   result ); \n         if ( rc   !=   LOGONSSOUSER_OK ) \n         { \n             printf ( \\n LogonSsoUserWithPin() failed: %d \\n ,   rc );  \n             return   FALSE ; \n         } \n         printf ( \\n  User logged on. Result of LogonSsoUserWithPin(): %d \\n ,   result ); \n         return   TRUE ; \n     } \n     printf ( InitLibrary() Failure \\n );  \n     return   FALSE ;  }", 
            "title": "Example 2: Log on a user with a smart card"
        }, 
        {
            "location": "/examples/#example-3-log-off-a-user", 
            "text": "This function performs a logoff from an SSO perspective, removing the user\u2019s credentials from the system for the purposes of future SSO-based authorization. Existing authorized sessions can still be used. If the previous user was not logged off, that user\u2019s credentials are restored (see example 4).  ICO/CCM interfaces can be used to perform full logoff/disconnect.  void   DoLogoffSsoUser ()  { \n   if   (   LogoffSsoUser ( 0 )   ==   LOGONSSOUSER_OK   )  \n      printf ( \\n  User logged off \\n ); \n   else \n      printf ( \\n  Error logging off user \\n \u201d);  }", 
            "title": "Example 3: Log off a user"
        }, 
        {
            "location": "/examples/#example-4-managing-an-exclusive-endpoint", 
            "text": "If the current user is not logged off and a new user is logged on, the previous user\u2019s credentials are saved by the system to be restored when the current user logs off. Only a single level of restore is supported. Logging off a second time without an intervening logon will result in clearing the SSO credentials and will require authentication before launching new sessions. This supports the following scenario using Controller, which is a custom application using  CtxCredApi ,  ICO :   A kiosk is auto-logged on with a default/generic user (could be the normal Windows logon or Controller calls  LogonSsoUser() )  The kiosk is then available with generic credentials for customer use.  Sales Rep A logs on with his own credentials:\n    a.  Controller calls  LogonSsoUser() .\n    b. Controller disconnects generic user\u2019s sessions.\n    c. Controller roams existing sessions for Sales Rep A.  The kiosk can launch new sessions using Sales Rep A\u2019s credentials.  Sales Rep A logs off:\n    a. Controller calls  LogoffSsoUser() , removing Sales Rep A\u2019s credentials and restoring the generic user.\n    b. Controller restores generic user\u2019s sessions.  The kiosk is back to its initial state and is available for use with generic credentials.  Sales Rep B logs on (repeat 3-5 for Sales Rep B).  The kiosk is back to its initial state.   This scenario can be repeated indefinitely.", 
            "title": "Example 4: Managing an exclusive endpoint"
        }, 
        {
            "location": "/examples/#example-5-managing-user-restore-and-shared-endpoints", 
            "text": "If the current user is not logged off and a new user is logged on, the previous user\u2019s credentials are saved by the system to be restored when the current user logs off. Only a single level of restore is supported. Logging off a second time without an intervening logon will result in clearing the SSO credentials and will require authentication before launching new sessions. This supports the following scenario using Controller, which is a custom application using CtxCredApi, ICO:   A nurse logs on normally and launches sessions. (Controller calls  LogonSsoUser()  or could be a Windows logon).  A doctor \u201ctaps in\u201d:\n    a. Controller executes  LogonSsoUser()  with the doctor\u2019s credentials.\n    b. Controller does not log off the nurse or disconnect sessions.\n    c. Controller causes any existing doctor\u2019s sessions to be roamed to this endpoint .  At this point both the nurse\u2019s and the doctor\u2019s sessions are active. New sessions will be launched using the doctor\u2019s credentials.  The doctor \u201ctaps out\u201d:\n    a. Controller calls  LogoffSsoUser() , removing the doctor\u2019s credentials and restoring the nurse\u2019s.\n    b. Controller disconnects the doctor\u2019s sessions.\n    c. The nurse\u2019s sessions are still active.   The nurse resumes as at Step 1.", 
            "title": "Example 5: Managing user restore and shared endpoints"
        }, 
        {
            "location": "/examples/#example-6-checking-for-reconnecting-sessions", 
            "text": "Some applications may need to determine whether sessions are being reconnected before launching new instances. The ICO interface, ICACLient::EnumerateCCMSessions(), reports the IDs of the ICA sessions that already exist and that are being formed. This interface can be used by the caller to heuristically determine whether new ICA sessions are being formed, for example after Receiver is restarted and is automatically reconnecting disconnected sessions.  After Receiver restarts, the caller may call this operation several times at regular intervals for a reasonable period of time (for example, two seconds). If, during that time, the operation reports new ICA sessions, the caller can conclude that those sessions are the reconnected sessions. If the period of time expires and the operation reports no new ICA sessions, the caller can conclude that no session reconnect attempts are being made. The IsReconnectInProgress() API can also be used to check for reconnecting sessions, as shown in the following example:  for   ( int   i   =   0 ;   i     40000 ;   i   +=   2000 ) \n     { \n         printf ( IsReconnectInProgress %d seconds left to wait \\n ,   ( 40000   -   i )   /  1000 ); \n         BOOL   bReconnectInProgress   =   FALSE ; \n         DWORD   status   =   pfnIsReconnectInProgress ( 2000 ,  bReconnectInProgress ); \n         if   ( status   ==   ERROR_SUCCESS ) \n         { \n             if   ( bReconnectInProgress ) \n              { \n                 printf ( IsReconnectInProgress: Reconnect in Progress \\n ); \n              } \n              else \n              { \n                 printf ( IsReconnectInProgress: No Reconnect \\n ); \n              } \n              break ; \n         } \n         else   if   ( status   ==   ERROR_TIMEOUT ) \n         { \n             printf ( IsReconnectInProgress: TIMEOUT \\n ); \n         } \n         else \n         { \n             printf ( IsReconnectInProgress: Error: %d \\n ,   status );  \n             break ; \n         } \n     }", 
            "title": "Example 6: Checking for reconnecting sessions"
        }
    ]
}